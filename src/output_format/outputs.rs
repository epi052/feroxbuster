use anyhow::Result;
use console::strip_ansi_codes;
use std::{
    fs,
    io::{self, Write},
};

use crate::{response::FeroxResponse, traits::FeroxSerialize};

#[derive(Copy, Clone, Debug, PartialEq)]
pub enum OutputFormat {
    /// config.json set to csv
    Csv,

    /// config.json set to json
    Json,

    /// default implementation if no format is selected
    Default,
}

/// implement a default for OutputFormat
impl Default for OutputFormat {
    /// return default (In this case its a str)
    fn default() -> Self {
        Self::Default
    }
}

pub fn output_csv() {}

#[allow(clippy::ptr_arg)]
pub fn format_arg_check(value: &String) -> bool {
    let config_value = &value.to_lowercase();
    let allowed_formats = vec!["csv", "json", "str"];
    for allowed in allowed_formats {
        if allowed.contains(config_value) {
            return true;
        }
    }
    false
}

pub fn write_to_csv(value: &FeroxResponse, file: &mut io::BufWriter<fs::File>) -> Result<()> {
    // note to future self: adding logging of anything other than error to this function
    // is a bad idea. we call this function while processing records generated by the logger.
    // If we then call log::... while already processing some logging output, it results in
    // the second log entry being injected into the first.

    let contents = value.as_csv();

    // This will not flush if it's a --format (csv) file due to writing the headers repeatedly,
    // therefore if someone ctrl+c the csv file will not be written. Not sure if there is an
    // easier way to ensure the headers write only once?
    //
    // There is a possibility it flushes when full and inadvertly writes the headers again.
    if file.buffer().is_empty() {
        write_response_csv_columns(file)?;
    }

    let contents = strip_ansi_codes(&contents);
    // This  determines if it's a csv file and headers have already been written

    file.write_all(contents.as_bytes())?;

    Ok(())
}

// A simple function to write the column headers for a FeroxResponse as_csv
pub fn write_response_csv_columns(file: &mut io::BufWriter<fs::File>) -> Result<()> {
    let csv_file_columns = vec![
        "url",
        "status",
        "wildcard",
        "content-length",
        "line-count",
        "word-count",
        "headers-x-content-type-options",
        "x-xss-protection",
        "headers-server",
        "headers-connection",
        "headers-access-control-allow-origin",
    ];

    file.write_all(
        format!(
            "{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}\n",
            csv_file_columns[0],
            csv_file_columns[1],
            csv_file_columns[2],
            csv_file_columns[3],
            csv_file_columns[4],
            csv_file_columns[5],
            csv_file_columns[6],
            csv_file_columns[7],
            csv_file_columns[8],
            csv_file_columns[9],
            csv_file_columns[10],
        )
        .as_bytes(),
    )?;

    Ok(())
}
